{
  "hash": "df3034a6cab94dd39ad65fd5c0a4eb29",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ndraft: false\ntitle: \"A simple data-logging service with Golang\"\ndate: \"2025-03-03\"\n---\n\n\n![](./cover2.webp)\n\n## TODOs\n\n::: {#01414b74 .cell execution_count=1}\n``` {.python .cell-code}\nprint(\"hello\")\nfor i in range(10):\n\tprint(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n:::\n:::\n\n\n- Continue writing about go API\n\t- Maybe show the `main()` func -- Showing adding handlers, graceful shutdown, channel for triggering when running etc. -- Helpful in tests\n\t- Talk about testing and the config the allows specifying a TestConfig\n\t- Config as a .go file for ease while it's small. If it was larger, it might be more maintainable/user friendly to use a TOML file, and then unmarshall it in Go, but then I just have to define the same structure twice.\n\t- Show the Dockerfile for multi-stage build of the service for reproducibly running in a container\n\t\t- Ideally show the size difference between a single stage and multi-stage build.\n\n- Write about the RPi Python service\n\t- Measurement devices can be connected via GPIO (or other ways, but this is particularly convenient on RPi/arduino type devices). \n\t- The choice of RPi makes it easy to use a python script and has some benefits with setting up initial wifi connection when prototyping locally. It's definitely massively overkill for what it needs to do. I'd definitely re-write in C for use on a much simpler and cheaper arduino if an significant scale is required, but for now, the ease of python is a good compromise.\n\t- The python script is simple but effective\n\t\t- Some error handling\n\t\t- Should add a rolling log (so that data can be uploaded when connection resumes if internet is lost)\n\t\t- Should start recording it's own timestamp (and then the server can store both server time and node time)\n\t\t- POSTs data to the endpoint periodically.\n\n\n## A simple data-logging service with Golang\n\nFor a side project, I needed a way to log environmental data in remote locations to a central database where the information can be viewed easily. I'm sure there are pre-built solutions out there for this, but I thought it would be a good opportunity to try out combining a few simple technologies and scripts. The following is an overview of that work.\n\nClick [here](https://ceraserver.adventuresoftim.com/dashboard) to see it in action. \n\nThe solution is broken down into three main parts:\n- An API that can store data logs from any of the edge devices\n- The data-logger itself that can run on a cheap piece of hardware anywhere.\n- A dashboard for viewing the logged information\n- A way to make these services available online\n\nTldr;\n- The data-logger is a python script that runs on a Raspberry Pi that is set up to run the service automatically on boot up. It sends POST requests to a web API to upload data when it gets an internet connection.\n- The API service is provided by a Golang program running in a minimal docker container that is hosted on a [DigitalOcean](https://digitalocean.com) droplet (virtual private server), and records the data to an sqlite database (after some basic authentication checks).\n- The dashboard is a [`Reflex`](https://reflex.dev) application, combining a Next.js frontend application, and a FastAPI backend to provide a single page application (SPA) that can interactively view the data recorded in the sqlite database. \n- A [CaddyXXX](XXX) docker container serves the Next.js frontend and reverse proxies both the Go API and the FastAPI backend. Providing automatic SSL management for secure communications.\n\nBelow is a slightly deeper dive into each of the separate parts. \n\n## The Go API\n\nStarting with the API, I just need something that allows me to easily upload various types of data with minimal fuss. The Go language has great built in support for building a HTTP server, as well as integrating with a database. It's also extremely fast and efficient. I'm not expecting to be working with a lot of data, but even if things scaled up massively, Go would remain a great choice.\n\nIn the end, I want to be able to log a range of parameters, but for simplicity, we'll just discuss recording the ambient temperature. For this, we need an API endpoint:\n\n```https://example.com/v1/log-temperature\n```\n\n::: {.callout-note}\nI've added the `v1` path parameter to make it easy to introduce a new version with otherwise breaking changes without actually breaking any loggers that rely on this initial implementation.\n:::\n\nWe'll make this accept POST requests and send a simple JSON datastructure:\n\n```json\n{\n\"temperature\": number,\n\"timestamp\": string, // RFC3339 format,\n\"status\": string // optional,\n}\n```\n\nIn addition, we'll include some headers in the request that act as identification of the node and authorization to post to this endpoint:\n\n```\nContent-Type: application/json\nX-authorization: <crypt key>\nX-node-id: <uuid>\n```\n\nSimilar endpoints can then be added for any other parameters that should be logged.\n\n\n### The `main` function\n\nWe can get a good overview of how the go program works by looking at the main function. The `main.go` file is where the various parts of the program are organized together to form a complete application. \n\nI'll discuss each part of the `main.go` file in parts below, the full file can be found [at the bottom of the page](#full-main-contents)\n\nStarting with the imports\n```go\npackage main\n\nimport (\n\t\"ceraserver/config\"\n\t\"ceraserver/internal/database\"\n\t\"ceraserver/pkg/api\"\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n)\n```\n\nWe can see that we are importing other parts of the project following a file structure that helps keep things organised. The file structure looks like:\n\n```\n.\n├── cmd\n│   └── init_db.go\n├── config\n│   └── config.go\n├── internal\n│   └── database\n│       └── sqlite.go\n├── pkg\n│   └── api\n│       └── handlers.go\n├── go.mod\n├── go.sum\n├── main.go\n├── main_test.go\n└── Taskfile.yml\n```\n\n(with a few things omitted for brevity).\n\nThe `main` function itself is:\n```go\nfunc main()\nCOPY IN THE REST HERE\n```\n\nAs you can see, the main function doesn't do much more than call the `run` function. This makes it convenient to test the application logic that lies within `run`. I discuss some basic testing [here XXX](#link to testing).\n\nNow let's look at the `run` function where the application logic lies. We first initialize the database, creating it if necessary.\n\n```go\nfunc run () {\n\n\tSHOW THE FIRST PART OF THE RUN FUNCTION -- SETTING UP THE DB\n...\n```\n\nThen we start setting up the http server by adding handlers\n\n```go\n...\nSHOW THE ADDING HANDLERS PART\n...\n```\n\nA very simple `healthcheck` handler make it easy to determine whether the service is running. \n\n::: {.aside}\nThe `healthcheck` handler is:\n\n```go\nHEALTHCHECK HANDLER\n```\n:::\n\nThe log temperature handler is defined in a separate file that we'll [look at later XXX](#link to later section). For now, we'll continue looking at setup of the server.\n\nNext, we start the http server as a goroutine:\n\n```go\nSHOW THE GOROUTINE FOR THE HTTP SERVER\n```\n\nWe send a signal back on the `XXX` channel that the server is started, primarily as helpful signal for tests to be able to wait until the server is ready before proceeding[^2])\n\n[^2]: A simpler but less robust alternative to using a channel and waiting for a signal is just to wait for some fixed time after telling the server to start before sending requests, and hoping that it will be ready in time. The problem with this is that setting a longer wait time delays the test unnecessary every single time it is run (which should be *very* often), but setting too short of a time could cause flaky or system dependent test failures (every developers worst nightmare), for example due to a less powerful machine running the tests in CI.  \n\n\nNow the server will being running forever. This alone would work, but it's better if we can provide a means to shutdown gracefully when possible. To do so we wait for interrupt signals:\n\n```go\nSHOW INTERRUPT AND GRACEFUL SHUTDOWN STUFF\n```\n\nThis allows us to stop the server with  `Ctrl+c` , and the program will let us know that the graceful shutdown was successful by a log to the console.\n\nThat's how the overall http server works, now let's take a quick look at the `main_test.go` file to see how this can be tested locally.\n\n\n### Testing main.go (MIGHT NEED A TAG HERE?>)\n\n....\n\n\n### Full main contents\n\nHere is the full `main.go` file contents in one chunk.\n\n\n```go\nINSERT MAIN.GO HERE\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}